I"Ÿ<h1 id="what-is-collaborative-filtering">What is Collaborative Filtering?</h1>

<p>By the name ‚Äúcollab‚Äù it means we are combining. In this case we combine multiple user
information and filter out the items that from the group of user that has similar tastes to the
user. In general it‚Äôs a technique for filtering an item, which a user might like on the basis of
combined actions by group of similar user</p>

<h1 id="algorithmn-and-concepts">Algorithmn and Concepts</h1>

<h2 id="euclidean-distance-score">Euclidean Distance Score</h2>

<p>Let‚Äôs say a person who has identical taste with other people is 1 and 0 for those who has no
similar taste with other people, so our similarity value ranges from 0 to 1. Since we are
combining people to find similarity among them and recommend a product depending on
how similar they are. In order to measure similarity, I will be using Euclidean Distance Score
in this article. There are many other measures depending on the problem you can chose
other distance score measures. For this article I will be using movie lens dataset where you
can find movie,user,rating.</p>
<ul>
  <li>Step 1: Load the dataset</li>
  <li>Step 2: Calculate the similarity score between each user. If ‚Äòuser1‚Äô is the one we are trying to
recommend to then calcuate the similairy between ‚Äòuser1‚Äô and all other users.</li>
</ul>
<center>d=‚àö((x2-x1)¬≤+(y2-y1)¬≤)</center>
<center>similarity score (r) = 1/(1+d)</center>

<ul>
  <li>Step 3: for every other user multiple each similarity we calculate in step 2 with the product
rating that user has not rated before. In this case we will be multiplying other product which
‚Äòuser1‚Äô has never rated before. It looks something like this in the figure below</li>
</ul>

<p><img src="/assets/images/tableML.JPG" alt="Recommendation Table" /></p>
<center><i><small>Table 1: Creating recommendation for User1</small></i></center>

<p>After multiplying similarity with each movie we calculate total of product of similarity and
movie for each movie. Similarly we calculate sum of similarity of user who has rated movie. If
you see blank in movie then its corresponding similarity value is not taken into consideration
while calculating sum. <em><small>Eg: In movie2 for user3 you can see blank so our similarity score for
movie2 is 0.99+0.38+0.92+0.66 = 2.95.</small></em> After calculating similarity we divide total/sim.sum
and that value is the predicted score.</p>

<h1 id="pre-requisites">Pre-requisites</h1>

<p>These are the following things you must do before getting started with implementation:</p>
<ul>
  <li>Make sure you have python installed in your system</li>
  <li>You must have basic knowledge of python programming</li>
</ul>

<h1 id="implementation-of-the-algorithm">Implementation of the Algorithm</h1>

<p>So far so good we have finished algorithm. Now Let‚Äôs make your had dirty using python.
Create a file called <em><small>recommendation.py</small></em>. Inside this file we are going to add all code that will be mentioned here.</p>

<pre><code class="language-python3">def loadMovieLens(path='/data/movielens'):
    # Get movie titles
    movies={}
    for line in open(path+'/u.item'):
        (id,title)=line.split('|')[0:2] movies[id]=title
    # Load data
    prefs={}
        for line in open(path+'/u.data'):
            (user,movieid,rating,ts)=line.split('\t') prefs.setdefault(user,{})
            prefs[user][movies[movieid]]=float(rating)
    return prefs
</code></pre>

<p>This will load movielens data and return dictionary. Now we have loaded datset in the same file we
will be calculating similary between users.</p>

<pre><code class="language-python3">from math import sqrt
# Returns a distance-based similarity score for person1 and person2
def sim_distance(prefs,person1,person2):
    # Get the list of shared_items
    si={}
    for item in prefs[person1]:
        if item in prefs[person2]:
            si[item]=1
    # if they have no ratings in common, return 0
    if len(si)==0: return 0
    # Add up the squares of all the differences
    sum_of_squares=sum([pow(prefs[person1][item]-prefs[person2][item],2) for item in prefs[person1] if item in prefs[person2]])
    return 1/(1+sum_of_squares)
</code></pre>

<h1 id="conclusion">Conclusion</h1>

<p>Collabarative filtering is useful when your dataset is small and keeps on changing. But it
does have some disadvantages like its computation time is significantly slower when your
dataset increases. So depending on the problem we can use this technique to recommend
product to users</p>
:ET